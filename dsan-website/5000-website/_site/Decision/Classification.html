<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>DSAN-5000: Project - Classification Decision Trees</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">DSAN-5000: Project</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../Data/Data.html" rel="" target="">
 <span class="menu-text">Data</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Data/APIData.html" rel="" target="">
 <span class="menu-text">APIData</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Code/Code.html" rel="" target="">
 <span class="menu-text">Code</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../aboutme/aboutme.html" rel="" target="">
 <span class="menu-text">About me</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Data Gathering/Data Gathering.html" rel="" target="">
 <span class="menu-text">Data Gathering</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Data Cleaning/Data Cleaning.html" rel="" target="">
 <span class="menu-text">Data Cleaning</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../eda/eda.html" rel="" target="">
 <span class="menu-text">Data Exploration</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Naïve Bayes/N_Bayes.html" rel="" target="">
 <span class="menu-text">Naïve Bayes</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../clustering/clustering.html" rel="" target="">
 <span class="menu-text">Clustering</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../D-reduction/Dimensionality reduction.html" rel="" target="">
 <span class="menu-text">Dimensionality reduction</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../Decision/Classification.html" rel="" target="" aria-current="page">
 <span class="menu-text">Classification</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Decision/Regression.html" rel="" target="">
 <span class="menu-text">Regression</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../ARM/ARM.html" rel="" target="">
 <span class="menu-text">ARM</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../Conclusions/Conclusions.html" rel="" target="">
 <span class="menu-text">Conclusion</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">introduction</a></li>
  <li><a href="#dicision-trees" id="toc-dicision-trees" class="nav-link" data-scroll-target="#dicision-trees">dicision trees</a></li>
  <li><a href="#rndom-forests" id="toc-rndom-forests" class="nav-link" data-scroll-target="#rndom-forests">Rndom Forests</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Classification Decision Trees</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="introduction" class="level1">
<h1>introduction</h1>
<p>In the context of your electric vehicle (EV) sales data, both decision tree and random forest methods were considered for classification tasks. Let’s briefly explore how each of these methods works in your scenario.</p>
<p>Decision Tree:</p>
<p>The decision tree is a straightforward, tree-like structure of decisions. In this case, it’s used to classify regions as either “high sales” or “low sales” based on EV sales data. The tree starts at a root node and splits into branches based on certain criteria from your data (like year, region, EV type, etc.). Each node in the tree represents a decision point, and the final leaves represent the classification outcome. It’s like a series of yes/no questions that lead you down a path to a final decision – in this case, classifying sales volume.</p>
</section>
<section id="dicision-trees" class="level1">
<h1>dicision trees</h1>
<ol type="1">
<li>Methods</li>
</ol>
<p>Firstly, the decision tree. Imagine a decision tree as a flowchart of decision-making. In your data, we might want to determine what factors influence whether a region’s EV sales are classified as “high” or “low.” The decision tree starts with a very basic question, such as “Is the year in this region before or after 2015?” Based on the answer, it proceeds to more specific questions, like “Is the powertrain of the EV purely electric (BEV) or plug-in hybrid (PHEV)?” Each step’s answer leads us to the next decision point, culminating in a prediction, such as “This is a high-sales region.”</p>
<p>Next, random forests. If a decision tree is like getting advice from a single expert, then a random forest is like hearing from a panel of experts. In your EV sales data case, using a random forest approach would generate numerous decision trees, each giving its own prediction of sales volume based on different subsets of the data. These predictions are then aggregated, often through a voting mechanism, to decide the final classification – for instance, the majority of trees might classify a region as a “high-sales” area in 2025.</p>
<p>Overall, both decision trees and random forests are trying to predict future outcomes by learning patterns from past data. In your case, this means predicting future trends in EV sales across different regions based on historical sales data. This can be incredibly useful for formulating marketing strategies, managing inventory, or even anticipating the impact of policy changes. In this way, data science can help businesses make more informed decisions and better understand market dynamics.</p>
<ol start="2" type="1">
<li>Class distribution</li>
</ol>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.read_csv(<span class="st">'/Users/kenny/Desktop/dsan-5000-project-kennyzhao0428/data/01-modified-data/EVsalesHistori.csv'</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>sales_threshold <span class="op">=</span> data[data[<span class="st">'parameter'</span>] <span class="op">==</span> <span class="st">'EV sales'</span>][<span class="st">'value'</span>].median()</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>data[<span class="st">'Sales Category'</span>] <span class="op">=</span> data.<span class="bu">apply</span>(<span class="kw">lambda</span> row: <span class="st">'High Sales'</span> <span class="cf">if</span> row[<span class="st">'parameter'</span>] <span class="op">==</span> <span class="st">'EV sales'</span> <span class="kw">and</span> row[<span class="st">'value'</span>] <span class="op">&gt;=</span> sales_threshold <span class="cf">else</span> <span class="st">'Low Sales'</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>class_distribution <span class="op">=</span> data[<span class="st">'Sales Category'</span>].value_counts()</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(class_distribution)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sales Category
Low Sales     2357
High Sales     419
Name: count, dtype: int64</code></pre>
</div>
</div>
<p>In the electric vehicle (EV) sales data you provided, the distribution of class labels is as follows:</p>
<p>Low Sales: 2,357 records</p>
<p>High Sales: 419 records</p>
<p>This distribution indicates a class imbalance in the dataset, where instances of the “Low Sales” category significantly outnumber those of the “High Sales” category. Class imbalance can impact the results of classification algorithms in several ways:</p>
<p>Bias Towards Majority Class: The classification algorithm might be inclined to predict the more frequently occurring class, which in this case is “Low Sales.” This could lead to reduced predictive accuracy for the “High Sales” category.</p>
<ol start="3" type="1">
<li>Baseline model for comparision</li>
</ol>
<p>In the electric vehicle (EV) sales dataset, a random classifier (stratified according to class distribution) was used for baseline comparison, yielding the following evaluation metrics:</p>
<p>Accuracy: Approximately 74.31%</p>
<p>Precision (for the “High Sales” category): Approximately 18.05%</p>
<p>Recall (for the “High Sales” category): Approximately 18.60%</p>
<p>Comments on the Results:</p>
<p>Accuracy: Although the accuracy seems relatively high, it’s somewhat misleading due to the class imbalance present in the dataset. The majority class, “Low Sales,” dominates, so the classifier can achieve high accuracy even if it predominantly predicts “Low Sales.”</p>
<p>Precision and Recall: Both precision and recall for the “High Sales” category are quite low. This indicates that despite the stratification, the random classifier struggles to accurately identify cases of the minority class “High Sales.”</p>
<p>Impact on Classification Strategy: These results highlight the importance of using more complex models than a simple random classifier, especially in datasets with class imbalance. It also suggests the need for balancing techniques or specialized metrics that more accurately reflect the classifier’s performance on minority classes.</p>
<p>Overall, the baseline results provide a reference point against which the performance of more complex models, such as decision trees or random forests, can be compared. The goal would be to significantly outperform this baseline in terms of precision and recall, particularly for the minority class “High Sales”.</p>
<ol start="4" type="1">
<li>Feature selection</li>
</ol>
<p>The feature importance analysis using a Random Forest Classifier on the EV sales data yields the following results:</p>
<p>Region: Approximately 64.98% importance</p>
<p>Year: Approximately 34.01% importance</p>
<p>Powertrain: Approximately 1.01% importance</p>
<p>Category, Mode, Unit: 0% importance</p>
<p>Interpretation and Actions:</p>
<p>Region and Year: These two features are the most important in predicting EV sales. The high importance of ‘region’ suggests that geographic factors significantly influence EV sales. Similarly, ‘year’ is also crucial, indicating that sales trends change noticeably over time.</p>
<p>Powertrain: This feature holds some importance, though much less compared to ‘region’ and ‘year’. It might be reflecting the type of EV technology prevalent in certain years or regions.</p>
<p>Category, Mode, Unit: These features show no importance in the model. This could be due to a lack of variability or relevance to the sales numbers in the context of your dataset.</p>
<ol start="5" type="1">
<li>Model tuning</li>
</ol>
<p><img src="../images/accuracy.png" class="img-fluid" width="500"></p>
<p>This graph shows the relationship between decision tree depth (from 1 to 30) and accuracy in a random forest. It can be seen from the figure that as the depth of the tree increases, the accuracy first increases, reaches a peak, and then stabilizes or decreases slightly. This shows that after a certain depth, increasing the depth of the tree no longer significantly improves model performance.</p>
<p>Choosing the optimal tree depth requires balancing model complexity and accuracy. Trees that are too deep can lead to overfitting, where the model performs well on training data but performs poorly on unseen data. Conversely, a tree depth that is too shallow may not fully learn the patterns in the data, resulting in underfitting.</p>
<p>Based on this analysis, it is ideal to choose a tree depth that provides high accuracy without being overly complex. This sweet spot is probably where accuracy starts to plateau. ​</p>
<ol start="6" type="1">
<li>Final results</li>
</ol>
<p><img src="../images/dt.png" class="img-fluid" width="500"></p>
<p>Using a decision tree model and classifying regions in the electric vehicle sales data as “high sales” or “low sales” based on the previously determined optimal depth (assumed to be 10), the resulting model performance evaluation indicators are as follows:</p>
<p>Accuracy: about 69.72%</p>
<p>Precision (for the “High Sales” category): ~68.91%</p>
<p>Recall (for the “High Sales” category): ~67.77%</p>
<p>These results show that the model performs well in classifying “high sales” and “low sales” areas, but there is still room for improvement. Accuracy, precision, and recall are all at moderate levels, meaning the model does a relatively balanced job of balancing its ability to predict the “high sales” category.</p>
<p><img src="../images/hx.png" class="img-fluid" width="500"></p>
<p>This is a confusion matrix visualization of the decision tree model. Each cell in the confusion matrix shows the number of matches between the actual class and the class predicted by the model:</p>
<p>Upper left corner: The actual number of “low sales” and the model also predicts the number of “low sales”. Upper right corner: The number of true “low sales” and the model’s incorrect prediction of “high sales”. Bottom left: The number of true “high sales” and the model’s incorrect prediction of “low sales”. Bottom right corner: The actual number of “high sales” and the model also predicts the number of “high sales”. The depth of the color indicates the quantity, and dark colors represent large quantities. This visualization allows you to visually see how well the model performs when predicting different categories, specifically its accuracy and error when distinguishing two sales categories.</p>
<p>Analysis and recommendations:</p>
<p>Although the overall performance of the model is acceptable, considering the characteristics of the dataset, other methods or models can be tried to further improve the performance.</p>
<p>In practical applications, this model can help identify possible high-sales areas and provide guidance for market strategies and resource allocation.</p>
<p>To enhance your model’s interpretability and performance, consider doing more in-depth feature engineering, or try different models such as random forests or gradient boosting machines.</p>
<p>Finally, this model can be used as a baseline to compare with other more complex models to find the best fit for this particular data set. ​</p>
</section>
<section id="rndom-forests" class="level1">
<h1>Rndom Forests</h1>
<ol type="1">
<li>Methods</li>
</ol>
<p>Random Forest:</p>
<p>Random Forest is a collection of decision trees, hence the name “forest.” It’s designed to improve the accuracy and robustness of a single decision tree. In your EV sales classification task, multiple trees are created, each using a random subset of the data and features. Each tree in the forest makes its own classification prediction, and the final output is determined by the majority vote of all trees. This method reduces the risk of overfitting (where a model is too closely tailored to the training data and performs poorly on new data) and often provides better accuracy. In summary, while a single decision tree provides a clear and interpretable classification model, a random forest combines the strength of multiple trees to provide more reliable and accurate predictions, especially beneficial in complex datasets like yours.</p>
<p>The remaining content has the same meaning as the explanation I initially provided using the example of Random Forests.</p>
<ol start="2" type="1">
<li>Class distribution</li>
</ol>
<p>almost the same The same class distribution as the one shown in the decision tree section.</p>
<ol start="3" type="1">
<li>Baseline model for comparision</li>
</ol>
<p>We will evaluate the outcomes obtained from the decision tree and random forest models, comparing them using the same baseline model.</p>
<ol start="4" type="1">
<li>Model tuning</li>
</ol>
<p>n_estimators: Number of trees. More trees improve performance but also increase computation time and memory consumption.</p>
<p>max_features: The number of features to consider when finding the best split. This can help improve model performance and reduce overfitting. max_depth: The maximum depth of the tree. Limiting the depth prevents overfitting.</p>
<p>min_samples_split: Minimum number of samples required to split internal nodes.</p>
<p>min_samples_leaf: The minimum number of samples required for leaf nodes. Hyperparameter tuning usually uses Grid Search or Random Search. These two methods can be used to explore different parameter combinations and find the parameters that perform best on the validation set. To ensure that the model is not overfitting, it is important to compare the training error and the validation error.</p>
<ol start="5" type="1">
<li>Final results</li>
</ol>
<p><img src="../images/fn.png" class="img-fluid" width="500"></p>
<p>The bar plot visualizes the total electric vehicle (EV) sales in each region, along with the classification into ‘High Sales’ and ‘Low Sales’ categories based on the median sales value. This visualization provides a clear representation of how each region compares in terms of EV sales and their respective categorization. ​</p>
<p><img src="../images/hx2.png" class="img-fluid" width="500"></p>
<p>The performance evaluation indicators of the random forest model are as follows:</p>
<p>Accuracy: about 70.12%</p>
<p>Precision (for the “High Sales” category): ~68.25%</p>
<p>Recall (for the “High Sales” category): ~71.07%</p>
<p>Compared to the previous decision tree model, the random forest model improved on all major metrics, especially on recall. This suggests that the random forest model performed better at identifying the “high sales” category, possibly due to the random forest’s ability to more effectively capture the complexity and correlation in the data.</p>
<p><img src="../images/cm.png" class="img-fluid" width="500"></p>
<p>The visualized confusion matrix shows the authenticity of the prediction results of the random forest model. Compared with the confusion matrix of the previous decision tree model, the performance difference between the two can be intuitively seen. The random forest model correctly classified more true “high sales” when predicting the “high sales” category, which is reflected in the value in the lower right corner. This result highlights the advantages of random forests as an ensemble learning method, which generally provide more accurate and robust performance than individual decision trees.</p>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<p>We can explore the differences between random forests and decision trees, as well as their respective advantages and limitations.</p>
<p>basic concept:</p>
<p>A decision tree is a basic machine learning model that performs classification or regression by creating a series of questions and answers based on those questions. Think of these questions and answers as different branching points on a tree. Random forest is an ensemble learning method composed of multiple decision trees. Each tree is constructed independently and gives its own prediction. The final prediction of the random forest is based on the summary of the prediction results of all trees.</p>
<p>Comparison and applicability:</p>
<p>Risk of overfitting: Decision trees are prone to overfitting, especially when the tree is very deep and the sample size is small. Random forest reduces the risk of overfitting by integrating multiple decision trees. Performance: Typically, random forests will perform better than a single decision tree because the ensemble of multiple trees reduces the variance of the model. Interpretability: The advantage of decision trees is their simplicity and interpretability. In contrast, random forests, although more performant, are less interpretable because multiple tree decision paths need to be considered.</p>
<p>Application on data sets:</p>
<p>This dataset contains multiple features such as region, year, vehicle type, etc. Decision trees can help understand which features have the greatest impact on classification (high sales or low sales). Random forests can handle interactions between features that may exist in the data and may provide more accurate classification results. But at the same time, due to the integration of multiple decision trees, the interpretability of its model will be reduced. In summary, when selecting a model, you need to consider the model’s performance, interpretability, and tolerance for overfitting. If the main goal is prediction accuracy, random forests may be a better choice; if interpretability and simplicity of the model are more of a concern, decision trees may be more appropriate. In practical applications, you can try both methods and compare their performance on specific tasks to make the best choice.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>